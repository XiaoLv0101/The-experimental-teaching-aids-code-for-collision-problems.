#include <Wire.h>
#include <MPU6050_light.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>
#include <SPI.h>

// --- 引脚和硬件定义 ---
#define TFT_CS    PA4
#define TFT_DC    PA2
#define TFT_RST   PA1
#define ST7735_INIT_TYPE  INITR_BLACKTAB
Adafruit_ST7735 tft(TFT_CS, TFT_DC, TFT_RST);
MPU6050 mpu(Wire);
#define TCRT5000_1_ANALOG_PIN PA0
#define TCRT5000_2_ANALOG_PIN PA3

// --- 阈值设置 ---
const int TCRT_THRESHOLD_1 = 2000;
const int TCRT_THRESHOLD_2 = 2000;
const float MIN_SWING_GYRO_THRESHOLD = 10.0;      // 角速度阈值，确认摆动开始
const float MIN_PEAK_CAPTURE_ANGLE_THRESHOLD = 3.0; // 角度阈值，确认是大幅度摆动，过滤噪声

// --- 测量结果与过程变量 ---
float finalPeakAngularVelocity = 0, finalPeakPendulumAngle = 0;
unsigned long finalTcrt1Duration = 0, finalTcrt2Duration = 0;
float currentPeakAngularVelocity = 0;
unsigned long tcrt1_detection_start_time = 0;
bool tcrt1_is_detecting = false, tcrt1_measurement_done = false;
unsigned long tcrt2_detection_start_time = 0;
bool tcrt2_is_detecting = false;
int tcrt2_pass_count = 0;
bool tcrt2_measurement_done = false;
bool mpu_measurement_done = false, mpu_is_swinging = false;
bool mpu_peak_detection_armed = false; // 新增！是否已“武装”峰值检测
float mpu_previous_gyro_x = 0;
bool measurementCompleted = false;

const unsigned long SERIAL_PRINT_INTERVAL = 200;

enum State { STATE_WAIT_TCRT1, STATE_MONITORING_PENDULUM, STATE_COMPLETE };
State currentState = STATE_WAIT_TCRT1;

void transitionToState(State nextState);
void updateScreen();

void setup(void) {
  Serial.begin(9600);
  Wire.begin();
  delay(100);
  if (mpu.begin() != 0) { while (1); }
  mpu.calcOffsets();
  tft.initR(ST7735_INIT_TYPE);
  pinMode(TCRT5000_1_ANALOG_PIN, INPUT);
  pinMode(TCRT5000_2_ANALOG_PIN, INPUT);
  transitionToState(STATE_WAIT_TCRT1);
}

void loop() {
  unsigned long currentMillis = millis();
  int tcrt1_reading = analogRead(TCRT5000_1_ANALOG_PIN);
  int tcrt2_reading = analogRead(TCRT5000_2_ANALOG_PIN);
  mpu.update();

  static unsigned long lastSerialPrintTime = 0;
  if (currentMillis - lastSerialPrintTime >= SERIAL_PRINT_INTERVAL) {
    Serial.print("T1_Val:"); Serial.print(tcrt1_reading);
    Serial.print(" | GyroX:"); Serial.print(mpu.getGyroX(), 1);
    Serial.print(" | AngleX:"); Serial.print(mpu.getAngleX(), 1);
    Serial.print(" | State:"); Serial.println(currentState);
    lastSerialPrintTime = currentMillis;
  }

  switch (currentState) {
    case STATE_WAIT_TCRT1: {
      bool is_blocked_now = (tcrt1_reading < TCRT_THRESHOLD_1);
      if (is_blocked_now && !tcrt1_is_detecting) {
        tcrt1_is_detecting = true;
        tcrt1_detection_start_time = currentMillis;
      } else if (!is_blocked_now && tcrt1_is_detecting) {
        tcrt1_is_detecting = false;
        finalTcrt1Duration = currentMillis - tcrt1_detection_start_time;
        tcrt1_measurement_done = true;
        
        // 重置所有后续测量模块的变量
        currentPeakAngularVelocity = 0; finalPeakAngularVelocity = 0; finalPeakPendulumAngle = 0;
        tcrt2_pass_count = 0; tcrt2_measurement_done = false; finalTcrt2Duration = 0;
        mpu_measurement_done = false; mpu_is_swinging = false; mpu_previous_gyro_x = 0;
        mpu_peak_detection_armed = false; // 重置新的标志位

        transitionToState(STATE_MONITORING_PENDULUM);
      }
      break;
    }

    case STATE_MONITORING_PENDULUM: {
      // --- MPU 测量逻辑 (采用新的三步法，更健壮) ---
      if (!mpu_measurement_done) {
        float currentGyroX = mpu.getGyroX();
        float currentAngleX = mpu.getAngleX();

        // 持续更新峰值角速度
        if (abs(currentGyroX) > currentPeakAngularVelocity) {
          currentPeakAngularVelocity = abs(currentGyroX);
        }

        // 步骤 1: 确认摆动已经开始
        if (!mpu_is_swinging && abs(currentGyroX) > MIN_SWING_GYRO_THRESHOLD) {
          mpu_is_swinging = true;
        }

        // 步骤 2: "武装"峰值检测。只有当摆动开始且角度足够大时，才准备捕捉峰值
        if (mpu_is_swinging && !mpu_peak_detection_armed) {
          if (abs(currentAngleX) > MIN_PEAK_CAPTURE_ANGLE_THRESHOLD) {
            mpu_peak_detection_armed = true;
            Serial.println(">>> MPU Peak Detection ARMED <<<");
          }
        }
        
        // 步骤 3: 捕获峰值。只有在“武装”后，才寻找角速度的零点穿越
        if (mpu_peak_detection_armed && (currentGyroX * mpu_previous_gyro_x < 0)) {
          finalPeakAngularVelocity = currentPeakAngularVelocity;
          finalPeakPendulumAngle = abs(currentAngleX);
          mpu_measurement_done = true;
          Serial.println(">>> MPU Peak CAPTURED <<<");
          updateScreen();
        }
        
        mpu_previous_gyro_x = currentGyroX;
      }

      // --- TCRT2 测量逻辑 (保持不变) ---
      if (!tcrt2_measurement_done) {
          bool tcrt2_currently_detecting = (tcrt2_reading < TCRT_THRESHOLD_2);
          if (tcrt2_currently_detecting) {
            if (!tcrt2_is_detecting) {
              tcrt2_is_detecting = true;
              tcrt2_detection_start_time = currentMillis;
            }
          } else {
            if (tcrt2_is_detecting) {
              tcrt2_is_detecting = false;
              tcrt2_pass_count++;
              if (tcrt2_pass_count == 2) {
                  finalTcrt2Duration = currentMillis - tcrt2_detection_start_time;
                  tcrt2_measurement_done = true;
                  updateScreen();
              }
            }
          }
      }

      if (mpu_measurement_done && tcrt2_measurement_done) {
          measurementCompleted = true;
          transitionToState(STATE_COMPLETE);
      }
      break;
    }

    case STATE_COMPLETE: break;
  }
}

void transitionToState(State nextState) {
  currentState = nextState;
  updateScreen();
  if (currentState == STATE_COMPLETE) {
      Serial.println("\n--- Final Results ---");
      Serial.print("TCRT1 Duration: "); Serial.print(finalTcrt1Duration); Serial.println(" ms");
      Serial.print("TCRT2 Duration: "); Serial.print(finalTcrt2Duration); Serial.println(" ms");
      Serial.print("Peak Gyro: "); Serial.print(finalPeakAngularVelocity, 1); Serial.println(" deg/s");
      Serial.print("Peak Angle: "); Serial.print(finalPeakPendulumAngle, 1); Serial.println(" deg");
      Serial.println("---------------------\n");
  }
}

void updateScreen() {
  tft.fillScreen(ST77XX_BLACK);
  tft.setCursor(0, 0);
  tft.setTextColor(ST77XX_WHITE);
  tft.setTextSize(1);
  tft.println("--- Measurement Progress ---");
  tft.print("Status: ");
  switch(currentState) {
    case STATE_WAIT_TCRT1: tft.println("Wait for ball pass"); break;
    case STATE_MONITORING_PENDULUM: tft.println("Monitoring pendulum..."); break;
    case STATE_COMPLETE: tft.println("All Done!"); break;
  }
  tft.println("");
  tft.setTextSize(2);
  tft.print("T1: ");
  if (tcrt1_measurement_done) { tft.print(finalTcrt1Duration); tft.println("ms"); } 
  else { tft.println("..."); }
  tft.print("T2: ");
  if (tcrt2_measurement_done) { tft.print(finalTcrt2Duration); tft.println("ms"); } 
  else { tft.println("..."); }
  tft.print("Gyro:");
  if (mpu_measurement_done) { tft.print(finalPeakAngularVelocity, 0); } 
  else { tft.print("..."); }
  tft.println(" d/s");
  tft.print("Angl:");
  if (mpu_measurement_done) { tft.print(finalPeakPendulumAngle, 0); } 
  else { tft.print("..."); }
  tft.println(" deg");
  if (measurementCompleted) {
    tft.setTextSize(1);
    tft.setCursor(0, tft.height() - 10);
    tft.setTextColor(ST77XX_GREEN);
    tft.println("Measurement Complete!");
  }
}
